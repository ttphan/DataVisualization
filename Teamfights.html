<!DOCTYPE html>
<html>
<head>
    <title>Team Fights DotA 2</title>
    <meta charset="utf-8">
    <link href=bootstrap-3.1.1-dist/css/bootstrap.css rel=stylesheet media="screen">
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.9.0.min.js"></script> 
    <script type="text/javascript" src="tipsy/javascripts/jquery.tipsy.js"></script>
    <link href="tipsy/stylesheets/tipsy.css" rel="stylesheet" type="text/css" />
</head>

<style>
    body {
        background-color: #2E2D34;
        font-size: 10pt;
    }

    svg {
        font: 10px sans-serif;
    }

    select {
        width:280px;
    }

    .tfEllipse {
        opacity:0.3;
    }

    #svgArea {
        float: left;
    }

    #wrapper {
        overflow: hidden;
    }

    .dropDown {
        width: auto;
        overflow: hidden;
        margin-top: 30px;
    }

    #left {
        float: left;
        width: 21%;
        padding-left: 15px;
    }

    #right {
        float: left;
        width: 21%;
    }


    .infoHeader, .tiers {
        color: white;
    }

    .hover {
        font-size: 14pt;
        font-style: oblique;
    } 

    .selecting .rects rect {
        fill-opacity: .1;
        stroke-opacity : .1;
    }
    .selecting .rects rect.selected {
      fill-opacity: 1;
      stroke-opacity : 1;
    }

    .resize path {
      fill: #666;
      fill-opacity: .8;
      stroke: #000;
      stroke-width: 1.5px;
    }

    .axis path, .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .brush .extent {
      fill-opacity: .125;
      shape-rendering: crispEdges;
    }

</style>


<body>
<h1 style="text-align: center; color:white"> Team Fights Defense of the Ancients 2 </h1>
<div id="wrapper">
    <div id="svgArea"></div>

    <div class="dropDown" id="left">
        <div class="tiers">
            <fieldset>
                <label><input type="radio" name="tierleft" value="All-left" checked autocomplete="off" onchange="toggleTier(this)"/> All</label>
                <label><input type="radio" name="tierleft" value="Normal-left" autocomplete="off" onchange="toggleTier(this)"/> Normal</label>
                <label><input type="radio" name="tierleft" value="High-left" autocomplete="off" onchange="toggleTier(this)"/> High</label>  
                <label><input type="radio" name="tierleft" value="VeryHigh-left" autocomplete="off" onchange="toggleTier(this)"/> Very High</label>  
                <label><input type="radio" name="tierleft" value="Pro-left" autocomplete="off" onchange="toggleTier(this)"/> Pro</label>  
            </fieldset>
        </div>
        
        <div id="dropDownLeft"></div>

        <div class="info" id="infoleft"></div>
    </div>

    <div class="dropDown" id="right">
        <div class="tiers">
            <fieldset>
                <label><input type="radio" name="tierright" value="All-right" checked autocomplete="off" onchange="toggleTier(this)"/> All</label>
                <label><input type="radio" name="tierright" value="Normal-right" autocomplete="off" onchange="toggleTier(this)"/> Normal</label>
                <label><input type="radio" name="tierright" value="High-right" autocomplete="off" onchange="toggleTier(this)"/> High</label>  
                <label><input type="radio" name="tierright" value="VeryHigh-right" autocomplete="off" onchange="toggleTier(this)"/> Very High</label>  
                <label><input type="radio" name="tierright" value="Pro-right" autocomplete="off" onchange="toggleTier(this)"/> Pro</label>  
            </fieldset>
        </div>
        <div id="dropDownRight"></div>

        <div class="info" id="inforight"></div>
    </div>
</div>

<div id="brush"></div>

<script src=D3/d3.js></script>
<script src=colorbrewer/colorbrewer.js></script>

<script>

//Margins, width and height of svg area.
var margin = {top: 10, right: 10, bottom: 10, left: 10},
        width = 768,
        height = 768;

//Svg object itself
var svg = d3.select("#svgArea").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

//The colorset used for coloring the ellipses, texts and timeline.
var colors = colorbrewer.Set1[9]
            .concat(colorbrewer.Set2[8])
            .concat(colorbrewer.Set3[12]);

// Remove gray colors from color sets to not collide with gray ellipses when another ellipse is hovered over
colors.splice(25,1);
colors.splice(16,1);
colors.splice(8,1);

// Make a matrix with labels of (x,y)-coordinates
var labels = create2DArray(124);
d3.csv("scripts/deliverables/Dota-Labels.csv", function(error, data) { 
    var zoneLabels = create2DArray(124);
    data.forEach(function(d) {
        d.x = +d.x;
        d.y = +d.y;
        d.SectionLabel = d.SectionLabel;
        zoneLabels[d.x][d.y] = d.SectionLabel;
    });
    labels = zoneLabels;
});


// Brush section
var maxleft = 0;
var maxright = 0;

// Margins, width and height of brush area.
var marginBrush = {top: 10, right: 15, bottom: 30, left: 20},
    widthBrush = 778,
    heightBrush = 75 - marginBrush.top - marginBrush.bottom;

// Scale of brush
var x = d3.scale.linear()
    .range([0, widthBrush])
    .domain([0, 0]);

// Brush initialization
var brush = d3.svg.brush()
    .x(x)
    .extent([0, 0])
    .on("brushstart", brushstart)
    .on("brush", brushmove)
    .on("brushend", brushend);

// Brush handle initialization
var arc = d3.svg.arc()
    .outerRadius(heightBrush / 2)
    .startAngle(0)
    .endAngle(function(d, i) { return i ? -Math.PI : Math.PI; });

// Axis scale initialization
var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")
    .tickFormat(
        function(d) {
            var time = computeTime(d);
            var output = "";

            if (time[0] > 0) {
                output = output + time[0] + "m ";
            }

            output = output + time[1] + "s";

            return output;
        })
    .tickValues(d3.range(0, 3600, 300));

// Initialization of the svg area for the brush
var svgBrush = d3.select("#brush").append("svg")
    .attr("width", widthBrush + marginBrush.left + marginBrush.right)
    .attr("height", heightBrush + marginBrush.top + marginBrush.bottom)
.append("g")
    .attr("transform", "translate(" + marginBrush.left + "," + marginBrush.top + ")");

// Set brush (selection) size properties
svgBrush.append("g")
    .attr("class", "x-axis")
    .attr("transform", "translate(0," + heightBrush + ")")
    .call(xAxis);

var brushg = svgBrush.append("g")
    .attr("class", "brush")
    .call(brush);

brushg.selectAll(".resize").append("path")
    .attr("transform", "translate(0," +  heightBrush / 2 + ")")
    .attr("d", arc);

brushg.selectAll("rect")
    .attr("height", heightBrush);

brushstart();
brushmove();

// Image of arena map is loaded here
svg.append("svg:image")
        .attr("x", margin.left)
        .attr("y", margin.top)
        .attr("width", width)
        .attr("height", height)
        .attr("xlink:href","HighResMap.jpg")


// Left dropdown menu
var dropDownLeft = d3.select("#dropDownLeft").append("select")
                    .attr("name", "matchlist-left");

dropDownLeft.on("change", menuChanged);

loadDropDown("left", "All");

// Right dropdown menu 
var dropDownRight = d3.select("#dropDownRight").append("select")
                    .attr("name", "matchlist-right");

dropDownRight.on("change", menuChanged);

loadDropDown("right", "All");



// Custom created `matches' file is read here. This is used for selecting matches in the application.
function loadDropDown(side, tier) {
    d3.csv("scripts/deliverables/matches.csv",function(error, data) {

        data.forEach(function(d) {
            d.match = +d.match;
            d.Tier = d.Tier;
        });

        //Filters the data by tier if specific tiers are selected
        var dataFiltered = data.filter(
            function (d) {
                if (tier == "All") {
                    return true;
                }
                return d.Tier == tier;
            }
        );

        dataFiltered.unshift(0);

        //Decide whether we're dealing with the left or right dropdown menu
        var options;
        var dropDown = dropDownLeft;

        if (side == "right") {
            dropDown = dropDownRight
        }

        dropDown.html("");

        //Add all options to the dropdown menus
        dropDown.append("option")
            .text("<SELECT A MATCH>");

        options = dropDown.selectAll("option")
                    .data(dataFiltered)
                    .enter()
                    .append("option");

        options.text(function (d) { return "Match id: " + d.match + ", tier: " + d.Tier; })
           .attr("value", function (d) { return d.match; });

    });
}

//Loads the visualization for the match corresponding to matchID. Resets the image if a new match is selected.
function getMatch(matchId, side) {
    computeSmallDD(matchId, side);
}

// Resets the visualization of one of the matches, depending on the side variable.
function reset(side) {
    var ellipses = svg.selectAll("ellipse");
    var rects = svgBrush.selectAll(".rects").selectAll("rect");

    var filteredEllipses = ellipses.filter(
        function(e) {
            return (e.side).indexOf(side) > -1;
        });

    var filteredRects = rects.filter(
        function(c) {
            return (c.side).indexOf(side) > -1;
        });

    filteredEllipses
        .data([])
        .exit()
        .remove();

    filteredRects
        .data([])
        .exit()
        .remove();

    d3.selectAll("#info" + side + " .infoChildren").remove();
    d3.selectAll("#info" + side + " .infoHeader").remove();
    d3.selectAll("#info" + side + " br").remove();
    d3.selectAll(".endline").remove();

}


//This function computes the points in time at which the players of both teams are close to their own team members 
//(small within-team distance, denoted as DD in the data files). This function also initiates the retrieval of other data.
function computeSmallDD(matchId, side) {
    var winArray = [];
    var loseArray = [];

    var winSmallDDArray = [];
    var loseSmallDDArray = [];

    var smallDDArray = [];

    //This var removes the first few seconds of the game from the data, since teams are automatically very close to each other during these first seconds while no teamfights will take place.
    var earlyGame = 50;

    // Smallest (100 * threshold)% of the win/loseArray. The higher this number, the more teamfights will be registered, but the more inaccurate this will become.
    var threshold = 0.3;

    d3.csv("scripts/deliverables/match-" + matchId + "-distance.csv", function(error, data) {
        data.forEach(function(d) {
            d.match = +d.match;
            d.team  = d.team;
            d.tsync = +d.tsync;
            d.DD    = +d.DD;
            d.Tier  = d.Tier;
            d.WinLose = d.WinLose;

            //Get all times at which teams are close together to each respective array.
            if (d.tsync > earlyGame) {
                if (d.WinLose == "Win") {
                    winArray.push([d.tsync, d.DD]);
                }
                else {
                    loseArray.push([d.tsync, d.DD]);
                }
            }
            
        });

        // Sort both arrays by DD and get the first (100*threshold)%.
        winArray.sort(comparison);
        loseArray.sort(comparison);

        for (var i = 0; i < (winArray.length*threshold); i++) {
            winSmallDDArray.push(winArray[i][0]);
            loseSmallDDArray.push(loseArray[i][0]);
        }

        //Intersect both arrays to find moments at which both teams are close to their team members and sort.
        smallDDIntersect(winSmallDDArray, loseSmallDDArray);

        smallDDArray.sort(function(a,b) { return a-b; });

        //Remove some noise (single second time points that appear in smallDDArray that can not possibly be team fights).
        smallDDArray = filterDD(smallDDArray);

        var clusterArray = defineClusters(smallDDArray);

        computeInterTeamDistArr(matchId, smallDDArray, clusterArray, side);


        function smallDDIntersect(arr1, arr2) {
            for (var i = 0; i < arr1.length; i++) {
                for (var j = 0; j < arr2.length; j++) {
                    if (arr1[i] == arr2[j]) {
                        smallDDArray.push(arr1[i]);
                    }
                }
            }
        }

        // Comparison for 2D arrays.
        function comparison(a, b) {
            return a[1] - b[1];
        }
    });

    return smallDDArray;
}

//Create clusters of time points that probably belong together.
function defineClusters(arr) {
    var cluster = {};
    var index = 0;
    cluster[arr[0]] = index;

    for (var i = 1; i < arr.length; i++) {
        if (arr[i+1] - arr[i] < 30) {
            cluster[arr[i]] = index;
        }
        else {
            cluster[arr[i]] = index;

            index++;
        }
    }

    return cluster;
}

/** 
 * Computes the inter-team distances, filters the clusters based on these distances and
 * draws the ellipses
 */
function computeInterTeamDistArr(matchId, smallDDArray, clusterArray, side) {
    var matchTime = 0;

    var posListWinX = [];
    var posListWinY = [];

    var posListLoseX = [];
    var posListLoseY = [];

    var interTeamThreshold = 30;

    d3.csv("scripts/deliverables/match-" + matchId + "-zones.csv", function(error, data) {

        var clusters = [];
        var winner;

        data.forEach(function(d) {
            d.t = +d.t;
            d.x = +d.x;
            d.y = +d.y;
            d.match = +d.match;
            d.team = d.team;
            d.player = d.player;
            d.won = +d.won;
            d.tstd = +d.tstd;
            d.tsync = +d.tsync;
            d.tper = +d.tper;
            d.tier = d.tier;
            d.zone = d.zone;

            if (winner == undefined && d.won == 1) {
                winner = d.team;
            }

            if (matchTime < d.tsync) {
                matchTime = d.tsync;
            }

            if (smallDDArray.indexOf(d.tsync)!=-1) {
                var clusterIndex = clusterArray[d.tsync];

                if (clusters[clusterIndex] == undefined) {
                    clusters[clusterIndex] = {
                        cIndex: clusterIndex,
                        side: side,
                        xAvg: 0,
                        yAvg: 0,
                        xSum: 0, 
                        ySum: 0, 
                        xHigh: 0, 
                        yHigh: 0, 
                        xLow: Number.POSITIVE_INFINITY, 
                        yLow: Number.POSITIVE_INFINITY,
                        cLength: 0,
                        totalZoneList: [],
                        mostZone: "",
                        mostZoneLength: 0, 
                        secondZone: "",
                        secondZoneLength: 0, 
                        time: []
                    };
                }

                var cluster = clusters[clusterIndex];


                //Fix index out-of-bounds problems with labels (sometimes a player walks on an (x,y)-coordinate that is not defined in the zone labels file)
                if (d.x > 123) {
                    d.x = 123;
                } else if (d.x < 0) {
                    d.x = 0
                }

                //Get area label for each coordinate
                labeld = labels[d.x][d.y];

                //Count the amount of times a teamfight was fought in each area for each teamfight.
                if (!(labeld in cluster.totalZoneList)) {
                    cluster.totalZoneList[labeld] = 1;    
                }else{
                    cluster.totalZoneList[labeld]++;
                }

                //Adjust the highest and lowest x,y properties if necessary.
                if (cluster.xHigh < d.x) {
                    cluster.xHigh = d.x;
                }
                if (cluster.xLow > d.x) {
                    cluster.xLow = d.x;
                }
                if (cluster.yHigh < d.y) {
                    cluster.yHigh = d.y;
                }
                if (cluster.yLow > d.y) {
                    cluster.yLow = d.y;
                }

                //Sum x and y positions and count length of teamfight
                cluster.xSum += d.x;
                cluster.ySum += d.y;
                cluster.cLength++;

                //Time of the teamfight
                cluster.time.push(d.tsync);

                //Add x and y positions to respective array based on winning or losing team at time index
                if (d.won==1) {
                    if (posListWinX[d.tsync] == null) {
                        posListWinX[d.tsync] = 0;
                    }
                    if (posListWinY[d.tsync] == null) {
                        posListWinY[d.tsync] = 0;
                    }

                    posListWinX[d.tsync] += d.x;
                    posListWinY[d.tsync] += d.y;
                } 
                else {
                    if (posListLoseX[d.tsync] == null) {
                        posListLoseX[d.tsync] = 0;
                    }
                    if (posListLoseY[d.tsync] == null) {
                        posListLoseY[d.tsync] = 0;
                    }

                    posListLoseX[d.tsync] += d.x;
                    posListLoseY[d.tsync] += d.y;
                }
            }

        });
            
        // Calculate average x and y positions per team
        var avgPosListWinX = avgArray(posListWinX);
        var avgPosListWinY = avgArray(posListWinY);
 
        var avgPosListLoseX = avgArray(posListLoseX);
        var avgPosListLoseY = avgArray(posListLoseY);

        // Calculate total average position of teamfight.
        var interTeamDistArr = euclArray(avgPosListWinX, avgPosListWinY, avgPosListLoseX, avgPosListLoseY);

        //Add info about match number, winner and the time at which a match ended
        var headers = d3.select("#info" + side);
        var teamfightHeader = headers.append("h1");

        headers.append("h4")
            .attr("class", "infoHeader")
            .text("Match id: " + matchId);

        headers.append("h4")
            .attr("class", "infoHeader")
            .text("Winner: " + winner);

        var matchTimeArray = computeTime(matchTime);

        headers.append("h4")
            .attr("class", "infoHeader")
            .text("End time: " + matchTimeArray[0] + ":" + matchTimeArray[1]);

        //Give each cluster a number (index) and filter them based on the distance between teams.
        var index = 0;
        var newClusters = [];

        clusters.forEach(function(cluster) {
            var minmax = d3.extent(cluster.time);

            var mean = d3.mean(interTeamDistArr.slice(minmax[0], minmax[1]), function(g) {
                if (g > 0) {
                    return g;
                }
            });

            //cLength > 30 is actually checking whether teamfights take longer than 3 seconds. This is multiplied times 10 to compensate for the fact that there are 10 players.
            if (mean <= interTeamThreshold && cluster.cLength > 30) {
                index++;
                cluster.cIndex = index;

                //Calculate the average x and y positions of a teamfight.
                cluster.xAvg = cluster.xSum / cluster.cLength;
                cluster.yAvg = cluster.ySum / cluster.cLength;

                //Zone where the largest part of the teamfight was fought.
                cluster.mostZone = objKeyOfMaxValue(cluster.totalZoneList);
                cluster.mostZoneLength = objMaxValue(cluster.totalZoneList);

                //Zone where the second to largest part of the teamfight was fought.
                cluster.secondZone = getKeySecondToMax(cluster.totalZoneList,secondToMaxValue(cluster.totalZoneList));
                cluster.secondZoneLength = secondToMaxValue(cluster.totalZoneList);

                // 10 players, so divide length by 10 to normalize
                cluster.cLength = cluster.cLength / 10;

                //Decide which match took longest and adjust the timeline (brush) accordingly
                if (side == "left") {
                    maxleft = matchTime;
                }
                else {
                    maxright = matchTime;
                }

                var info = d3.select("#info" + side);
                
                var start = computeTime(minmax[0]);
                var end = computeTime(minmax[1]);

                // Checkboxes for ellipses
                info.append("p")
                    .attr("class", "infoChildren")
                    .attr("id", function() { return "text-" + side + index})
                    .html(
                        function() {
                            return "<label><input id='checkbox-" + side + index + "' type='checkbox' name='checkbox-" + side + "' value='" + side + "-" + index + "' checked autocomplete='off' onchange='toggleEllipse(this)'/>" +
                            " Team Fight " + index + 
                            " (" + start[0] + ":" + start[1] + " - " 
                                + end[0] + ":" + end[1] + ")"
                            +"</label>";
                        }
                    )
                    .style("color", 
                        function() {
                            if (side == "left") {
                                return colors[index - 1];
                            }

                            return colors[colors.length - (index)];
                        }
                    )
                    .on("mouseover", enlargeEllipseData)
                    .on("mouseleave", shrinkEllipseData)
                    
                // Tooltips when hovering over text
                $('.infoChildren').tipsy({
                    gravity: 
                        function() {
                            if (side == "left") {
                                return "w";
                            }
                            else {
                                return "e";
                            }
                        },
                    fade: true,
                    html: true,
                    offset: 5,
                    title: 
                    function() { 
                        var dat = cluster;
                        var tfNumber = dat.cIndex;

                        var cLength = dat.cLength * 10;
                        var mostZone = dat.mostZone;
                        var mostZoneLength = dat.mostZoneLength
                        var secondZone = dat.secondZone;

                        //If more than 60 percent of a teamfight was fought in one area, show only one area. Otherwise, show two areas in tooltip.
                        if(mostZoneLength / cLength > 0.6) {
                            secondZone = 0;
                        }

                        var minmax = d3.extent(dat.time);

                        var duration = minmax[1]-minmax[0];

                        var time = computeTime(duration);

                        if(time[1].length==2 && time[1][0] == "0") {
                            time[1] = time[1][1];
                        }

                        var matchNumber;
                        if(side == "left") {
                            matchNumber = 1;
                        }
                        else{
                            matchNumber = 2;
                        }

                        if(secondZone!=0) {
                        return "Team fight " + tfNumber + " (match "+ matchNumber +")" + " was mainly fought in the following areas: " + "<h4>" + mostZone + "</h4>" + " and " + "<h4>" + secondZone + "</h4>" + 
                        "This team fight took " + time[0] + " minutes and " + time[1] + " seconds." //*****
                        }
                        else {
                            return "Team fight " + tfNumber + " (match "+ matchNumber +")" + " was mainly fought in the following area: " + "<h4>" + mostZone + "</h4>" + 
                            "This team fight took " + time[0] + " minutes and " + time[1] + " seconds." //*****
                        }
                    }
                });
                
                //Add the cluster to the filtered cluster list.
                newClusters.push(cluster);
            }
        });

        clusters = newClusters;

        // Reset and redraw the brush, timeline and rectangles on the timeline
        resetBrush(side);

        //Show how many teamfights happened in each match
        teamfightHeader.attr("class", "infoHeader")
            .text(Object.keys(clusters).length + " Team Fights");

        ellipseIndex = 0;

        //Each ellipse's size is based on the average x and y positions and the highest and lowest x and y coordinates of a teamfight. 
        //Teamfights that were spread over a larger area will lead to larger ellipses.
        svg.append("g")
            .selectAll("ellipse")
            .data(clusters)
            .enter()
            .append("ellipse")
            .property("type", 0)
            .attr("id", 
                function(c) { 
                    ellipseIndex++; 
                    return "ellipse-" + side + ellipseIndex; 
                }
            )
            .attr("cx",
                function(c) {
                    return ((c.xAvg * 6) + 3) + 15;
                }
            )
            .attr("cy",
                function(c) {
                    return (((124 - c.yAvg) * 6) + 3) + 15;
                }
            )
            .attr("rx",
                function(c) {
                    return ((c.xHigh - c.xLow) / 2);
                }
            )
            .attr("ry",
                function(c) {
                    return ((c.yHigh - c.yLow) / 2);
                }
            )
            .attr("display", "inline")
            .style("fill-opacity", 
                function(c) {
                    if (side == "left") {
                        return 0.75;
                    }

                    return 0;
                }
            )//Hovering over ellipses will make other ellipses gray for more contrast and enlarge the corresponding text in the menu on the right.
            .style("stroke-opacity", 0.75)
            .style("stroke-width", "5")
            .style("stroke",
                function(c) {
                    if (side == "right") {
                        return colors[colors.length - c.cIndex];
                    }

                    return "none";
                }
            )//Hovering over ellipses will make other ellipses gray for more contrast and enlarge the corresponding text in the menu on the right.
            .style("fill", 
                function(c) {
                    return colors[c.cIndex - 1];

                })
            .on("mouseover", enlargeEllipseData)
            .on("mouseleave", shrinkEllipseData);

        // Show tooltips when hovering over ellipses
        $('svg ellipse').tipsy({
            gravity: 'w',
            fade: true,
            html: true,
            offset: 5,
            title: 
                function(d) { 
                    var dat = this.__data__;
                    var tfNumber = dat.cIndex;

                    var cLength = dat.cLength * 10;
                    var mostZone = dat.mostZone;
                    var mostZoneLength = dat.mostZoneLength
                    var secondZone = dat.secondZone;

                    //If more than 60 percent of a teamfight was fought in one area, show only one area. Otherwise, show two areas in tooltip.
                    if(mostZoneLength / cLength > 0.6) {
                        secondZone = 0;
                    }

                    //var tfMinutes = Math.floor(dat.cLength / 60); //*****
                    //var tfSeconds = Math.floor(dat.cLength % 60); //*****
                    var minmax = d3.extent(dat.time);

                    var duration = minmax[1]-minmax[0];

                    var time = computeTime(duration);

                    if(time[1].length==2 && time[1][0] == "0") {
                        time[1] = time[1][1];
                    }                    

                    var matchNumber;
                    if(side == "left") {
                        matchNumber = 1;
                    }
                    else {
                        matchNumber = 2;
                    }
                    
                    if(secondZone!=0) {
                        return "Team fight " + tfNumber + " (match "+ matchNumber +")" + " was mainly fought in the following areas: " + "<h4>" + mostZone + "</h4>" + " and " + "<h4>" + secondZone + "</h4>" + 
                        "This team fight took " + time[0] + " minutes and " + time[1] + " seconds." //*****
                    }
                    else {
                        return "Team fight " + tfNumber + " (match "+ matchNumber +")" + " was mainly fought in the following area: " + "<h4>" + mostZone + "</h4>" + 
                        "This team fight took " + time[0] + " minutes and " + time[1] + " seconds." //*****
                    }
                }
        });
        
        function resetBrush() {
            // Resize the brush scale
            var max = d3.max([maxleft, maxright]);

            x.domain([0, max]);
            xAxis.tickValues(d3.range(0, max, 300));

            svgBrush.selectAll("g.x-axis")
                .call(xAxis);

            // Redraw brush
            brush.clear();
            brush.extent([0, max]); 
            svgBrush.selectAll('.brush').call(brush);

            // Resize existing rectangles to match the new scale
            svgBrush.selectAll(".rects").selectAll("rect")
                .attr("width",
                    function(c) {
                        var extents = d3.extent(c.time);

                        return x(extents[1] - extents[0]);
                    }
                )

            // Draw the new rectangles
            svgBrush.append("g").classed("rects", true).selectAll("rect")
                .data(clusters)
            .enter().append("rect")
                .attr("width",
                    function(c) {
                        var extents = d3.extent(c.time);

                        return x(extents[1] - extents[0]);
                    }
                )
                .attr("height", 5)
                .attr("rx", 2)
                .attr("ry", 2)
                .style("stroke-width", "1")
                .style("stroke",
                    function(c) {
                        if (side == "right") {
                            return colors[colors.length - c.cIndex];
                        }

                        return "none";
                    }
                )
                .style("fill",
                    function(c) {
                        if (side == "left") {
                            return colors[c.cIndex - 1];
                        }

                        return "none"
                    }
                );

            // Draws the white line that indicates the end of the shortest match.
            if (d3.min([maxleft, maxright]) > 0) {
                svgBrush.append("g").classed("endline", true).selectAll("line")
                    .data([d3.min([maxleft, maxright])])
                .enter().append("line")
                    .attr("x1", 
                        function(d) {
                            return x(d);
                        }
                    )
                    .attr("x2", 
                        function(d) {
                            return x(d);
                        }
                    )
                    .attr("y1", 0)
                    .attr("y2", heightBrush)
                    .attr("stroke-width", 2)
                    .attr("stroke", "white");
            }

            // Transform x position
            svgBrush.selectAll(".rects").selectAll("rect")
                .attr("transform", 
                    function(c) { 
                        var offset = 10;

                        if (c.side == "right") {
                            offset = 25;
                        }

                        return "translate(" + x(d3.extent(c.time)[0]) + "," + offset + ")"; 
                    }
                )

            brushmove();
        }        
    });
}

/**
 * Utility Functions
 */

/**
 * Computes the start and end times based on the extends, 
 * returns the minutes and seconds of both start and end times.
 */
function computeTime(time) {
    var result = [];

    result[0] = Math.floor(time / 60);
    result[1] = time % 60;
    if (result[1] < 10) {
        result[1] = "" + 0 + result[1];
    }

    return result;
}

/**
 * Gives the css class 'selecting' to the brush at startup of application
 */
function brushstart() {
    svgBrush.classed("selecting", true);
}

/**
 * Handles the sliding of the brush and associated showing/hiding of ellipses
 */
function brushmove() {
    var s = brush.extent();
    var rects = svgBrush.selectAll(".rects").selectAll("rect");

    rects.classed("selected", 
        function(c) { 
            var extents = d3.extent(c.time);
            var checkbox = $('#checkbox-' + c.side + c.cIndex);
            var selected = true;

            // +1 to take into account the very last team fight
            if (s[0] <= extents[0] && extents[1] <= s[1] + 1) {
                checkbox.prop("checked", true);
            }
            else {             
                checkbox.prop("checked", false);
                selected = false;
            }

            toggleEllipse(checkbox[0]);
            return selected;
        }
    );
}

function brushend() {
    svgBrush.classed("selecting", !d3.event.target.empty());
}

//Handles the toggling of the tier radio buttons
function toggleTier(element) {
    var tier = (element.value).split("-")[0];
    var side = (element.value).split("-")[1];

    loadDropDown(side, tier);
}

//Handles showing/hiding of ellipses when checkboxes are checked/unchecked respectively
function toggleEllipse(element) {
    var side = (element.value).split("-")[0];
    var index = (element.value).split("-")[1];
    var display = element.checked ? "inline" : "none";

    svg.selectAll("ellipse")
        .filter(function(d) { 
            if (side == d.side) {
                return d.cIndex == index;
            }

            return false;
        }
        )
        .attr("display", display);
}

//Handles hovering over an ellipse, during which corresponding text in menu gets enlarged and all other ellipses are turned gray.
var enlargeEllipseData = function() {
    var ellipseIndex = (this.id).split('-')[1];
    var text = d3.select("#text-" + ellipseIndex);
    var side = ellipseIndex.replace(/[0-9]/g, '');

    var numberPattern = /\d+/g;

    svg.selectAll("ellipse")
        .transition().duration(250)
        .style("fill",
            function(c) {
                // All other ellipses
                if (c.cIndex != ellipseIndex.match(numberPattern) || c.side != side) {
                    return "gray";
                }
                // Selected ellipse
                else {
                    return colors[c.cIndex - 1];
                }

            }
        )
        .style("stroke",
            function(c) {
                if (c.side == "left") {
                    return "none";
                }
                else {
                    // All other ellipses
                    if (c.cIndex != ellipseIndex.match(numberPattern) || c.side != side) {
                        return "gray";
                    }
                    // Selected ellipse
                    else {
                        return colors[colors.length - c.cIndex];
                    }
                }
            }
        )

    text.classed('hover', true);
}

//Handles setting back the correct colors of all ellipses after not hovering over an ellipse anymore. Also shrinks back the corresponding text in the menu again.
var shrinkEllipseData = function() {
    var ellipse = d3.select(this);
    var ellipseIndex = (this.id).split('-')[1];
    var text = d3.select("#text-"+ellipseIndex);
    
    svg.selectAll("ellipse")
        .transition().duration(250)
        .style("fill", 
            function(c) { 
                return colors[c.cIndex - 1]; 
            }
        )
        .style("stroke",
            function(c) {
                if (c.side == "left") {
                    return "none";
                }

                return colors[colors.length - c.cIndex];
            }
        );

    text.classed('hover', false);  

}

/**
 * Object functions, calculating either values or corresponding keys, e.g. calculating max value of all properties of an object.
 */
function getKeySecondToMax(obj, value) { 
    for (o in obj) {
        if(obj.hasOwnProperty(o)) {
            if (obj[o] === value) {
                return o;
            }
        }
    }
}

function secondToMaxValue(obj) { 
    var max = -1;
    var secondMax = -1;
    for(o in obj) {
        if(obj[o] > max) {
            secondMax = max;
            max = obj[o];
        } else if (obj[o] > secondMax) {
            secondMax = obj[o];
        }
    }
    return secondMax;
}

function objTotalValue(obj) { 
    var total = 0;
    for(o in obj) {
        total += obj[o];
    }
    return total;
}

function objKeyOfMaxValue(obj) { 
    var max = -1;
    var key = "";
    for(o in obj){
        if(obj[o] > max) {
            max = obj[o];
            key = o;
        }
    }
    return key;
}

function objMaxValue(obj) { 
    var max = -1;
    for(o in obj){
        if(obj[o] > max) {
            max = obj[o];
        }
    }
    return max;
}


/**
 * Array functions
 */
function create2DArray(rows) {
  var arr = [];

  for (var i=0;i<rows;i++) {
     arr[i] = [];
  }

  return arr;
}

function eucl(x1, y1, x2, y2) {
    dx = Math.abs(x1-x2);
    dy = Math.abs(y1-y2);
    distance = Math.sqrt((dx*dx) + (dy*dy));
    return(distance);
}   

function makeArrayOf(value, length) {
  var arr = [];
  var i = length;
  while (i--) {
    arr[i] = value;
  }
  return arr;
}

function avgArray(arr) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] > 0) {
            newArr[i] = arr[i] / 5;
        }
        else {
            newArr[i] = 0;
        }
    }

    return newArr;
}

function euclArray(arr1, arr2, arr3, arr4) {
    var euclArr = [];
    for (var i = 0; i < arr1.length; i++) {
        euclArr[i] = eucl(arr1[i], arr2[i], arr3[i], arr4[i]);
    }
    return euclArr;
}


/**
 * Handles changing of matches in dropdown menus
 */
function menuChanged() {
    var selectedValue = d3.event.target.value;
    var side = (this.name).split("-")[1];

    reset(side);
    
    if (!isNaN(selectedValue) && selectedValue > 0) {
        getMatch(selectedValue, side);
    }
}

/**
 * Removes 'noise' from smallDDArray
 */
function filterDD(arr) {
    var newArr = [];
    var length = 0;

    for (var i = 0; i < arr.length; i++) {
        if (i == 0) {
            if (arr[i+1] != arr[i]+1) {
                arr[i] = 0;
            }
            else {
                newArr.push(arr[i]);
            }
        }
        else if (i == arr.length-1) {
            if (arr[i-1] != arr[i]-1) {
                arr[i] = 0;
            } 
            else {
                newArr.push(arr[i]);
            }
        } 
        else {
            if (arr[i-1] != arr[i]-1 && arr[i+1] != arr[i]+1) {
                arr[i] = 0;
            }
            else { 
                newArr.push(arr[i]);
            }
        }
    }
    return newArr;
}


</script>
</body>
</html>