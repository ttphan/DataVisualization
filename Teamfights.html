<!DOCTYPE html>
<html>
<head>
    <title>Exercise-3</title>
    <meta charset="utf-8">
    <link href=bootstrap-3.1.1-dist/css/bootstrap.css rel=stylesheet media="screen">
</head>


<style>
    body {
        background-color: #2E2D34;
    }

    svg {
        font: 10px sans-serif;
    }

    .gridCircle {
        opacity:0;
    }

    .tfCircle {
        opacity:1;
    }

    #svgArea {
        float: left;
    }

    #wrapper {
        overflow: hidden;
    }

    #dropDown {
        width: auto;
        overflow: hidden;
        padding-left: 100px;
        padding-top: 50px;
    }


</style>


<body>

<div id="wrapper">
    <div id="svgArea"></div>

    <div id="dropDown"></div>
</div>

<script src=D3/d3.js></script>
<script src=jquery-2.1.0.min/jquery-2.1.0.min.js></script>

<script>

var margin = {top: 10, right: 10, bottom: 10, left: 10},
        width = 768,
        height = 768;


var svg = d3.select("#svgArea").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g");


//!!!!!!!!!IMAGE HERE!!!!!!!!!!
svg.append("svg:image")
        .attr("x", margin.left)
        .attr("y", margin.top)
        .attr("width", width)
        .attr("height", height)
        .attr("xlink:href","HighResMap.jpg")


var dropDown = d3.select("#dropDown").append("select")
                    .attr("name", "match-list");

dropDown.on("change", menuChanged);

dropDown.append("option")
    .text("<SELECT A MATCH>");

d3.csv("scripts/deliverables/matches.csv",function(error, data) {
    data.unshift(0);

    data.forEach(function(d) {
        d.match = +d.match;
        d.Tier = d.Tier;
    });

    var options = dropDown.selectAll("option")
                    .data(data)
                    .enter()
                    .append("option");

    options.text(function (d) { return "Match id: " + d.match + ", tier: " + d.Tier; })
       .attr("value", function (d) { return d.match; });        
});

//Inkleuren van de kaart.
d3.csv("data/Dota-Labels.csv",function(error, data) {
    data.forEach(function(d) {
        d.x = +d.x;
        d.y = +d.y;
        d.SectionLabel = d.SectionLabel;
        d.LabelValue = +d.LabelValue;
    });

    var color = d3.scale.category20();


    circle = svg.append("g")
        .selectAll("circle")
        .data(data)
        .enter()
        .append("circle")
        .attr("cx", function(d){return ((d.x * 6) + 3) + 15})
        .attr("cy", function(d){return (((124 - d.y) * 6) + 3) + 15})
        .attr("r", 3)
        .attr("class","gridCircle")
        .style("fill", 
                function(d) { 
                if(d.LabelValue != 17 && d.LabelValue != 18){
                    return color(d.LabelValue); 
                }
            }
        );
});


/**
 * Functions
 */

function eucl(x1, y1, x2, y2) {
    dx = Math.abs(x1-x2);
    dy = Math.abs(y1-y2);
    distance = Math.sqrt((dx*dx) + (dy*dy));
    return(distance);
}   

function makeArrayOf(value, length) {
  var arr = [];
  var i = length;
  while (i--) {
    arr[i] = value;
  }
  return arr;
}

function avgArray(arr) {
    var newArr = [];
    for(var i = 0; i < arr.length; i++) {
        if(arr[i] > 0) {
            newArr[i] = arr[i] / 5;
        }
        else {
            newArr[i] = 0;
        }
    }

    return newArr;
}

function euclArray(arr1, arr2, arr3, arr4) {
    var euclArr = [];
    for(var i = 0; i < arr1.length; i++) {
        euclArr[i] = eucl(arr1[i], arr2[i], arr3[i], arr4[i]);
    }
    return euclArr;
}

function menuChanged() {
    var selectedValue = d3.event.target.value;
    
    if (!isNaN(selectedValue) && selectedValue > 0) {
        console.log(selectedValue);
        getMatch(selectedValue);
    }
}

function getMatch(matchId) {
    var smallDDArray = computeSmallDD(matchId);
    var interTeamDistArr = computeInterTeamDistArr(matchId, smallDDArray);
}

function computeSmallDD(matchId) {
    var winArray = [];
    var loseArray = [];

    var winSmallDDArray = [];
    var loseSmallDDArray = [];

    var smallDDArray = [];

    var earlyGame = 100;

    // Smallest (100 * n)% of the win/loseArray
    var treshold = 0.3;

    d3.csv("scripts/deliverables/match-" + matchId + "-distance.csv", function(error, data) {
        data.forEach(function(d) {
            d.match = +d.match;
            d.team  = d.team;
            d.tsync = +d.tsync;
            d.DD    = +d.DD;
            d.Tier  = d.Tier;
            d.WinLose = d.WinLose;

            if (d.tsync > earlyGame) {
                if (d.WinLose == "Win") {
                    winArray.push([d.tsync, d.DD]);
                }
                else {
                    loseArray.push([d.tsync, d.DD]);
                }
            }
            
        });

        // Sort both arrays by DD and get the first (100*treshold)%.
        winArray.sort(comparison);
        loseArray.sort(comparison);

        for (var i = 0; i < (winArray.length*treshold); i++) {
            winSmallDDArray.push(winArray[i][0]);
            loseSmallDDArray.push(loseArray[i][0]);
        }

        smallDDIntersect(winSmallDDArray, loseSmallDDArray);

        function smallDDIntersect(arr1, arr2) {
            for(var i = 0; i < arr1.length; i++) {
                for(var j = 0; j < arr2.length; j++) {
                    if(arr1[i] == arr2[j]) {
                        smallDDArray.push(arr1[i]);
                    }
                }
            }
            console.log(smallDDArray);
        }

        // Comparison for double arrays
        function comparison(a, b) {
            return a[1] - b[1];
        }
    });

    return smallDDArray;
}

function computeInterTeamDistArr(matchId, smallDDArray) {
    var matchTime;
    var winTeamPlayers = [];
    var loseTeamPlayers = [];

    var xPosWin = 0;
    var yPosWin = 0;

    var xPosLose = 0;
    var yPosLose = 0;

    var posListWinX = [];
    var posListWinY = [];

    var posListLoseX = [];
    var posListLoseY = [];

    d3.csv("scripts/deliverables/match-" + matchId + "-zones.csv", function(error, data) {
        matchTime = 1;
        data.forEach(function(d) {
            d.t = +d.t;
            d.x = +d.x;
            d.y = +d.y;
            d.match = +d.match;
            d.team = d.team;
            d.player = d.player;
            d.won = +d.won;
            d.tstd = +d.tstd;
            d.tsync = +d.tsync;
            d.tper = +d.tper;
            d.tier = d.tier;
            d.zone = d.zone;

            if (matchTime < d.tsync + 1) {
                matchTime = d.tsync + 1;
            }

            
            if (smallDDArray.indexOf(d.tsync)!=-1){
                if (d.won==1){
                    if (posListWinX[d.tsync] == null) {
                        posListWinX[d.tsync] = 0;
                    }
                    if (posListWinY[d.tsync] == null) {
                        posListWinY[d.tsync] = 0;
                    }

                    posListWinX[d.tsync] += d.x;
                    posListWinY[d.tsync] += d.y;
                }else {
                    if (posListLoseX[d.tsync] == null) {
                        posListLoseX[d.tsync] = 0;
                    }
                    if (posListLoseY[d.tsync] == null) {
                        posListLoseY[d.tsync] = 0;
                    }

                    posListLoseX[d.tsync] += d.x;
                    posListLoseY[d.tsync] += d.y;
                }
            }

        });

        var avgPosListWinX = avgArray(posListWinX);
        // console.log("avgPosListWinX: ");
        // console.log(avgPosListWinX);
        var avgPosListWinY = avgArray(posListWinY);
        // console.log("avgPosListWinY: ");
        // console.log(avgPosListWinY);
      
        var avgPosListLoseX = avgArray(posListLoseX);
        // console.log("avgPosListLoseX: ");
        // console.log(avgPosListLoseX);
        var avgPosListLoseY = avgArray(posListLoseY);
        // console.log("avgPosListLoseY: ");
        // console.log(avgPosListLoseY);

        //Lijst met alle afstanden tussen teams op tijdstippen waarop DD kleiner is dan een bepaalde waarde.
        var interTeamDistArr = euclArray(avgPosListWinX, avgPosListWinY, avgPosListLoseX, 
            avgPosListLoseY);

        console.log(interTeamDistArr);

        var color = d3.scale.category10();


        circle = svg.append("g")
        .selectAll("circle")
        .data(data)
        .enter()
        .append("circle")
        .attr("cx", 
            function(d) {
                if(avgPosListWinX.indexOf(Math.round(d.x))!=-1) {
                    return (((d.x * 6) + 3) + 15);
                }
            }
        )
        .attr("cy", 
            function(d) {
                if(avgPosListWinY.indexOf(Math.round(d.y))!=-1) {
                    return (((124 - d.y) * 6) + 3) + 15;
                }
            }
        )
        .attr("r", 3)
        .attr("class","tfCircle")
        .style("fill", 
                function(d) { 
                if(d.LabelValue != 17 && d.LabelValue != 18){
                    return color(d.LabelValue); 
                }
            }
        );

        /**
        * Hier functie om players op te halen, weet niet of dit nog nodig is, hoorde bij een eerste aanpak van gisteravond.
        */
        //console.log("winning team:" + winTeamPlayers);
        //console.log("losing team:" + loseTeamPlayers);

        function createPlayerLists(d) {
            if(d.won == 1 && (winTeamPlayers.indexOf(d.player) == -1)) { //
                winTeamPlayers.push(d.player);
            } else if(d.won == 0 && (loseTeamPlayers.indexOf(d.player) == -1)){ //
                loseTeamPlayers.push(d.player);
            }
        }



    });
}


</script>
</body>
</html>