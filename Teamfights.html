<!DOCTYPE html>
<html>
<head>
    <title>Team Fights DotA 2</title>
    <meta charset="utf-8">
    <link href=bootstrap-3.1.1-dist/css/bootstrap.css rel=stylesheet media="screen">
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.9.0.min.js"></script> 
    <script type="text/javascript" src="src/javascripts/jquery.tipsy.js"></script>
    <link href="src/stylesheets/tipsy.css" rel="stylesheet" type="text/css" />
</head>

<style>
    body {
        background-color: #2E2D34;
        font-size: 10pt;
    }

    svg {
        font: 10px sans-serif;
    }

    select {
        width:280px;
    }

    .tfEllipse {
        opacity:0.3;
    }

    #svgArea {
        float: left;
    }

    #wrapper {
        overflow: hidden;
    }

    .dropDown {
        width: auto;
        overflow: hidden;
        margin-top: 30px;
    }

    #left {
        float: left;
        width: 21%;
        padding-left: 15px;
    }

    #right {
        float: left;
        width: 21%;
    }


    .infoHeader, .tiers {
        color: white;
    }

    .hover {
        font-size: 14pt;
        font-style: oblique;
    } 

    .selecting .rects rect {
        fill-opacity: .1;
        stroke-opacity : .1;
    }
    .selecting .rects rect.selected {
      fill-opacity: 1;
      stroke-opacity : 1;
    }

    .resize path {
      fill: #666;
      fill-opacity: .8;
      stroke: #000;
      stroke-width: 1.5px;
    }

    .axis path, .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .brush .extent {
      fill-opacity: .125;
      shape-rendering: crispEdges;
    }

</style>


<body>
<h1 style="text-align: center; color:white"> Team Fights Defense of the Ancients 2 </h1>
<div id="wrapper">
    <div id="svgArea"></div>

    <div class="dropDown" id="left">
        <div class="tiers">
            <fieldset>
                <label><input type="radio" name="tierleft" value="All-left" checked autocomplete="off" onchange="toggleTier(this)"/> All</label>
                <label><input type="radio" name="tierleft" value="Normal-left" autocomplete="off" onchange="toggleTier(this)"/> Normal</label>
                <label><input type="radio" name="tierleft" value="High-left" autocomplete="off" onchange="toggleTier(this)"/> High</label>  
                <label><input type="radio" name="tierleft" value="VeryHigh-left" autocomplete="off" onchange="toggleTier(this)"/> Very High</label>  
                <label><input type="radio" name="tierleft" value="Pro-left" autocomplete="off" onchange="toggleTier(this)"/> Pro</label>  
            </fieldset>
        </div>
        
        <div id="dropDownLeft"></div>

        <div class="info" id="infoleft"></div>
    </div>

    <div class="dropDown" id="right">
        <div class="tiers">
            <fieldset>
                <label><input type="radio" name="tierright" value="All-right" checked autocomplete="off" onchange="toggleTier(this)"/> All</label>
                <label><input type="radio" name="tierright" value="Normal-right" autocomplete="off" onchange="toggleTier(this)"/> Normal</label>
                <label><input type="radio" name="tierright" value="High-right" autocomplete="off" onchange="toggleTier(this)"/> High</label>  
                <label><input type="radio" name="tierright" value="VeryHigh-right" autocomplete="off" onchange="toggleTier(this)"/> Very High</label>  
                <label><input type="radio" name="tierright" value="Pro-right" autocomplete="off" onchange="toggleTier(this)"/> Pro</label>  
            </fieldset>
        </div>
        <div id="dropDownRight"></div>

        <div class="info" id="inforight"></div>
    </div>
</div>

<div id="brush"></div>

<script src=D3/d3.js></script>
<script src=lib/colorbrewer.js></script>

<script>

var margin = {top: 10, right: 10, bottom: 10, left: 10},
        width = 768,
        height = 768;

var svg = d3.select("#svgArea").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

var colors = colorbrewer.Set1[9]
            .concat(colorbrewer.Set2[8])
            .concat(colorbrewer.Set3[12]); 

var labels = create2DArray(124);
d3.csv("data/Dota-Labels.csv", function(error, data) { 
    var zoneLabels = create2DArray(124);
    data.forEach(function(d) {
        d.x = +d.x;
        d.y = +d.y;
        d.SectionLabel = d.SectionLabel;
        zoneLabels[d.x][d.y] = d.SectionLabel;
    });
    labels = zoneLabels;
});


// Brush section
var maxleft = 0;
var maxright = 0;

var marginBrush = {top: 10, right: 15, bottom: 30, left: 20},
    widthBrush = 778,
    heightBrush = 75 - marginBrush.top - marginBrush.bottom;

// Format seconds to mm:ss format
formatMinutes = function(d) { 
    var minutes = Math.floor(d / 60),
        seconds = d - (minutes * 60);
    var output = seconds + 's';
    if (minutes) {
        output = minutes + 'm ' + output;
    }

    return output;
};

var x = d3.scale.linear()
    .range([0, widthBrush])
    .domain([0, 0]);

var brush = d3.svg.brush()
    .x(x)
    .extent([0, 0])
    .on("brushstart", brushstart)
    .on("brush", brushmove)
    .on("brushend", brushend);

var arc = d3.svg.arc()
    .outerRadius(heightBrush / 2)
    .startAngle(0)
    .endAngle(function(d, i) { return i ? -Math.PI : Math.PI; });

var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")
    .tickFormat(formatMinutes)
    .tickValues(d3.range(0, 3600, 300));

var svgBrush = d3.select("#brush").append("svg")
    .attr("width", widthBrush + marginBrush.left + marginBrush.right)
    .attr("height", heightBrush + marginBrush.top + marginBrush.bottom)
.append("g")
    .attr("transform", "translate(" + marginBrush.left + "," + marginBrush.top + ")");

svgBrush.append("g")
    .attr("class", "x-axis")
    .attr("transform", "translate(0," + heightBrush + ")")
    .call(xAxis);

var brushg = svgBrush.append("g")
    .attr("class", "brush")
    .call(brush);

brushg.selectAll(".resize").append("path")
    .attr("transform", "translate(0," +  heightBrush / 2 + ")")
    .attr("d", arc);

brushg.selectAll("rect")
    .attr("height", heightBrush);

brushstart();
brushmove();

//Remove gray colors from color sets
colors.splice(8,1);
colors.splice(15,1);
colors.splice(23,1);

//Image of map is loaded here
svg.append("svg:image")
        .attr("x", margin.left)
        .attr("y", margin.top)
        .attr("width", width)
        .attr("height", height)
        .attr("xlink:href","HighResMap.jpg")

// Left menu
var dropDownLeft = d3.select("#dropDownLeft").append("select")
                    .attr("name", "matchlist-left");

dropDownLeft.on("change", menuChanged);

loadDropDown("left", "All");

// Right menu 
var dropDownRight = d3.select("#dropDownRight").append("select")
                    .attr("name", "matchlist-right");

dropDownRight.on("change", menuChanged);

loadDropDown("right", "All");



//Custom created `matches' file is read here. This is used for selecting matches in the application.
function loadDropDown(side, tier) {
    d3.csv("scripts/deliverables/matches.csv",function(error, data) {

        data.forEach(function(d) {
            d.match = +d.match;
            d.Tier = d.Tier;
        });

        var dataFiltered = data.filter(
            function (d) {
                if (tier == "All") {
                    return true;
                }
                return d.Tier == tier;
            }
        );

        dataFiltered.unshift(0);

        var options;

        if (side == "left") {
            dropDownLeft.html("");

            dropDownLeft.append("option")
                .text("<SELECT A MATCH>");


            options = dropDownLeft.selectAll("option")
                        .data(dataFiltered)
                        .enter()
                        .append("option");
        }
        else {
            dropDownRight.html("");

            dropDownRight.append("option")
                .text("<SELECT A MATCH>");

            options = dropDownRight.selectAll("option")
                        .data(dataFiltered)
                        .enter()
                        .append("option");
        }

        options.text(function (d) { return "Match id: " + d.match + ", tier: " + d.Tier; })
           .attr("value", function (d) { return d.match; });

    });
}

//Loads the visualization for the match corresponding to matchID. Resets the image if a new match is selected.
function getMatch(matchId, side) {
    computeSmallDD(matchId, side);
}

// Removes the ellipses and team fight info.
function reset(side) {
    var ellipses = svg.selectAll("ellipse");
    var rects = svgBrush.selectAll(".rects").selectAll("rect");

    var filteredEllipses = ellipses.filter(
        function(e) {
            return (e.side).indexOf(side) > -1;
        });

    var filteredRects = rects.filter(
        function(c) {
            return (c.side).indexOf(side) > -1;
        });

    filteredEllipses
        .data([])
        .exit()
        .remove();

    filteredRects
        .data([])
        .exit()
        .remove();

    d3.selectAll("#info" + side + " .infoChildren").remove();
    d3.selectAll("#info" + side + " .infoHeader").remove();
    d3.selectAll("#info" + side + " br").remove();

}


//This function computes the points in time at which the players of both teams are close to their team members 
//(small intra-team distance). This function also initiates the retrieval of other data.
function computeSmallDD(matchId, side) {
    var winArray = [];
    var loseArray = [];

    var winSmallDDArray = [];
    var loseSmallDDArray = [];

    var smallDDArray = [];

    var earlyGame = 100;

    // Smallest (100 * n)% of the win/loseArray
    var threshold = 0.3;

    d3.csv("scripts/deliverables/match-" + matchId + "-distance.csv", function(error, data) {
        data.forEach(function(d) {
            d.match = +d.match;
            d.team  = d.team;
            d.tsync = +d.tsync;
            d.DD    = +d.DD;
            d.Tier  = d.Tier;
            d.WinLose = d.WinLose;

            if (d.tsync > earlyGame) {
                if (d.WinLose == "Win") {
                    winArray.push([d.tsync, d.DD]);
                }
                else {
                    loseArray.push([d.tsync, d.DD]);
                }
            }
            
        });

        // Sort both arrays by DD and get the first (100*threshold)%.
        winArray.sort(comparison);
        loseArray.sort(comparison);

        for (var i = 0; i < (winArray.length*threshold); i++) {
            winSmallDDArray.push(winArray[i][0]);
            loseSmallDDArray.push(loseArray[i][0]);
        }

        //Intersect both arrays to find moments at which players of both teams are close to their team members.
        smallDDIntersect(winSmallDDArray, loseSmallDDArray);

        smallDDArray.sort(function(a,b) { return a-b; });

        //Remove some noise (single time points that appear in smallDDArray that can not possibly be team fights).
        smallDDArray = filterDD(smallDDArray);

        var clusterArray = defineClusters(smallDDArray);

        computeInterTeamDistArr(matchId, smallDDArray, clusterArray, side);


        function smallDDIntersect(arr1, arr2) {
            for (var i = 0; i < arr1.length; i++) {
                for (var j = 0; j < arr2.length; j++) {
                    if (arr1[i] == arr2[j]) {
                        smallDDArray.push(arr1[i]);
                    }
                }
            }
        }

        // Comparison for 2D arrays.
        function comparison(a, b) {
            return a[1] - b[1];
        }
    });

    return smallDDArray;
}

//Create clusters of time points that probably belong together.
function defineClusters(arr) {
    var cluster = {};
    var index = 0;
    cluster[arr[0]] = index;

    for (var i = 1; i < arr.length; i++) {
        if (arr[i+1] - arr[i] < 30) {
            cluster[arr[i]] = index;
        }
        else {
            cluster[arr[i]] = index;

            index++;
        }
    }

    return cluster;
}

/** 
 * Computes the inter-team distances, filters the clusters based on these distances and
 * draws the ellipses
 */
function computeInterTeamDistArr(matchId, smallDDArray, clusterArray, side) {
    var matchTime = 0;
    var winTeamPlayers = [];
    var loseTeamPlayers = [];

    var xPosWin = 0;
    var yPosWin = 0;

    var xPosLose = 0;
    var yPosLose = 0;

    var posListWinX = [];
    var posListWinY = [];

    var posListLoseX = [];
    var posListLoseY = [];

    var interTeamThreshold = 30;

    d3.csv("scripts/deliverables/match-" + matchId + "-zones.csv", function(error, data) {

        var clusters = [];
        var winner;

        data.forEach(function(d) {
            d.t = +d.t;
            d.x = +d.x;
            d.y = +d.y;
            d.match = +d.match;
            d.team = d.team;
            d.player = d.player;
            d.won = +d.won;
            d.tstd = +d.tstd;
            d.tsync = +d.tsync;
            d.tper = +d.tper;
            d.tier = d.tier;
            d.zone = d.zone;

            if (winner == undefined && d.won == 1) {
                winner = d.team;
            }

            if (matchTime < d.tsync) {
                matchTime = d.tsync;
            }

            if (smallDDArray.indexOf(d.tsync)!=-1) {
                var clusterIndex = clusterArray[d.tsync];

                if (clusters[clusterIndex] == undefined) {
                    clusters[clusterIndex] = {
                        cIndex: clusterIndex,
                        side: side,
                        xAvg: 0,
                        yAvg: 0,
                        xSum: 0, 
                        ySum: 0, 
                        xHigh: 0, 
                        yHigh: 0, 
                        xLow: Number.POSITIVE_INFINITY, 
                        yLow: Number.POSITIVE_INFINITY,
                        cLength: 0,
                        totalZoneList: [],
                        mostZone: "",
                        secondZone: "",
                        time: []
                    };
                }

                var cluster = clusters[clusterIndex];


                labeld = labels[d.x][d.y];

                if(!(labeld in cluster.totalZoneList)) {
                    cluster.totalZoneList[labeld] = 1;    
                }else{
                    cluster.totalZoneList[labeld]++;
                }

                if (cluster.xHigh < d.x) {
                    cluster.xHigh = d.x;
                }
                if (cluster.xLow > d.x) {
                    cluster.xLow = d.x;
                }
                if (cluster.yHigh < d.y) {
                    cluster.yHigh = d.y;
                }
                if (cluster.yLow > d.y) {
                    cluster.yLow = d.y;
                }

                cluster.xSum += d.x;
                cluster.ySum += d.y;
                cluster.cLength++;

                cluster.time.push(d.tsync);


                if (d.won==1) {
                    if (posListWinX[d.tsync] == null) {
                        posListWinX[d.tsync] = 0;
                    }
                    if (posListWinY[d.tsync] == null) {
                        posListWinY[d.tsync] = 0;
                    }

                    posListWinX[d.tsync] += d.x;
                    posListWinY[d.tsync] += d.y;
                } 
                else {
                    if (posListLoseX[d.tsync] == null) {
                        posListLoseX[d.tsync] = 0;
                    }
                    if (posListLoseY[d.tsync] == null) {
                        posListLoseY[d.tsync] = 0;
                    }

                    posListLoseX[d.tsync] += d.x;
                    posListLoseY[d.tsync] += d.y;
                }
            }

        });
        
        var avgPosListWinX = avgArray(posListWinX);
        var avgPosListWinY = avgArray(posListWinY);
 
        var avgPosListLoseX = avgArray(posListLoseX);
        var avgPosListLoseY = avgArray(posListLoseY);



        // Array containing distances between team fights by tsync.
        var interTeamDistArr = euclArray(avgPosListWinX, avgPosListWinY, avgPosListLoseX, avgPosListLoseY);

        var interTeamThreshold = 30;

        var h1 = d3.select("#info" + side);

        var teamfightHeader = h1.append("h1");

        h1.append("h4")
            .attr("class", "infoHeader")
            .text("Match id: " + matchId);

        h1.append("h4")
            .attr("class", "infoHeader")
            .text("Winner: " + winner);


        var index = 0;
        var newClusters = [];

        clusters.forEach(function(cluster) {
            var minmax = d3.extent(cluster.time);

            var mean = d3.mean(interTeamDistArr.slice(minmax[0], minmax[1]), function(g) {
                if (g > 0) {
                    return g;
                }
            });
            //cLength > 30 is actually checking whether teamfights take longer than 3 seconds. This is multiplied times 10 to compensate for the fact that there are 10 players.
            if (mean <= interTeamThreshold && cluster.cLength > 30) {
                index++;
                cluster.cIndex = index;


                cluster.xAvg = cluster.xSum / cluster.cLength;
                cluster.yAvg = cluster.ySum / cluster.cLength;

                cluster.mostZone = objKeyOfMaxValue(cluster.totalZoneList);
                cluster.secondZone = getKeySecondToMax(cluster.totalZoneList,secondToMaxValue(cluster.totalZoneList));

                // 10 players, so divide by 10
                cluster.cLength = cluster.cLength / 10;

                var minMin = Math.floor(minmax[0] / 60);
                var minSec = minmax[0] % 60;
                if (minSec < 10) {
                    minSec = "" + 0 + minSec;
                }

                var maxMin = Math.floor(minmax[1] / 60);
                var maxSec = minmax[1] % 60;
                if (maxSec < 10) {
                    maxSec = "" + 0 + maxSec;
                }

                if (side == "left") {
                    maxleft = matchTime;
                }
                else {
                    maxright = matchTime;
                }

                var info = d3.select("#info" + side);
                
                // Checkboxes
                info.append("p")
                    .attr("class", "infoChildren")
                    .attr("id", function() { return "text-" + side + index})
                    .html(
                        function() {
                            return "<label><input id='checkbox-" + side + index + "' type='checkbox' name='checkbox-" + side + "' value='" + side + "-" + index + "' checked autocomplete='off' onchange='toggleEllipse(this)'/>" +
                            " Team Fight " + index + 
                            " (" + minMin + ":" + minSec + " - " 
                                + maxMin + ":" + maxSec + ")"
                            +"</label>";
                        }
                    )
                    .style("color", 
                        function() {
                            if (side == "left") {
                                return colors[index - 1];
                            }

                            return colors[colors.length - (index)];
                        }
                    )
                    .on("mouseover", enlargeEllipseData)
                    .on("mouseleave", shrinkEllipseData)
                    
                // Tooltips on text
                $('.infoChildren').tipsy({
                gravity: 
                    function() {
                        if (side == "left") {
                            return "w";
                        }
                        else {
                            return "e";
                        }
                    },
                fade: true,
                html: true,
                offset: 5,
                title: 
                    function() { 
                        var dat = cluster;
                        var tfNumber = dat.cIndex;
                        var mostZone = dat.mostZone;
                        var secondZone = dat.secondZone;
                        var tfMinutes = Math.floor(dat.cLength / 60);
                        var tfSeconds = Math.floor(dat.cLength % 60);
                        var matchNumber;
                        if(side == "left") {
                            matchNumber = 1;
                        }
                        else{
                            matchNumber = 2;
                        }

                        return "Team fight " + tfNumber + " (match "+ matchNumber +")" + " was mainly fought in the following areas: " + "<h4>" + mostZone + "</h4>" + " and " + "<h4>" + secondZone + "</h4>" + 
                        "This team fight took " + tfMinutes + " minutes and " + tfSeconds + " seconds."
                    }
                });

                newClusters.push(cluster);
            }
        });


        clusters = newClusters;

        // Reset and redraw the brush and rectangles
        resetBrush(side);

        teamfightHeader.attr("class", "infoHeader")
            .text(Object.keys(clusters).length + " Team Fights");

        ellipseIndex = 0;

        svg.append("g")
            .selectAll("ellipse")
            .data(clusters)
            .enter()
            .append("ellipse")
            .property("type", 0)
            .attr("id", 
                function(c) { 
                    ellipseIndex++; 
                    return "ellipse-" + side + ellipseIndex; 
                }
            )
            .attr("cx",
                function(c) {
                    return ((c.xAvg * 6) + 3) + 15;
                }
            )
            .attr("cy",
                function(c) {
                    return (((124 - c.yAvg) * 6) + 3) + 15;
                }
            )
            .attr("rx",
                function(c) {
                    return ((c.xHigh - c.xLow) / 2);
                }
            )
            .attr("ry",
                function(c) {
                    return ((c.yHigh - c.yLow) / 2);
                }
            )
            .attr("display", "inline")
            .style("fill-opacity", 
                function(c) {
                    if (side == "left") {
                        return 0.75;
                    }

                    return 0;
                }
            )
            .style("stroke-opacity", 0.75)
            .style("stroke-width", "5")
            .style("stroke",
                function(c) {
                    if (side == "right") {
                        return colors[colors.length - c.cIndex];
                    }

                    return "none";
                }
            )
            .style("fill", 
                function(c) {
                    return colors[c.cIndex - 1];

                })
            .on("mouseover", enlargeEllipseData)
            .on("mouseleave", shrinkEllipseData);

        // Tooltips on ellipses
        $('svg ellipse').tipsy({
            gravity: 'w',
            fade: true,
            html: true,
            offset: 5,
            title: 
                function(d) { 
                    var dat = this.__data__;
                    var tfNumber = dat.cIndex;
                    var mostZone = dat.mostZone;
                    var secondZone = dat.secondZone;
                    var tfMinutes = Math.floor(dat.cLength / 60);
                    var tfSeconds = Math.floor(dat.cLength % 60);
                    var matchNumber;
                    if(side == "left") {
                        matchNumber = 1;
                    }
                    else{
                        matchNumber = 2;
                    }
                    

                    return "Team fight " + tfNumber + " (match "+ matchNumber +")" + " was mainly fought in the following areas: " + "<h4>" + mostZone + "</h4>" + " and " + "<h4>" + secondZone + "</h4>" + 
                    "This team fight took " + tfMinutes + " minutes and " + tfSeconds + " seconds."
                }
        });

        function resetBrush() {
            // Resize the brush scale
            var max = maxleft;

            if (maxleft < maxright) {
                max = maxright;
            }

            x.domain([0, matchTime]);
            xAxis.tickValues(d3.range(0, matchTime, 300));

            svgBrush.selectAll("g.x-axis")
                .call(xAxis);

            // Redraw brush
            brush.clear();
            brush.extent([0, matchTime]);
            svgBrush.selectAll('.brush').call(brush);

            // Resize existing rectangles to match the new scale
            svgBrush.selectAll(".rects").selectAll("rect")
                .attr("width",
                    function(c) {
                        var extents = d3.extent(c.time);

                        return x(extents[1] - extents[0]);
                    }
                )

            // Draw the new rectangles
            svgBrush.append("g").classed("rects", true).selectAll("rect")
                .data(clusters)
            .enter().append("rect")
                .attr("width",
                    function(c) {
                        var extents = d3.extent(c.time);

                        return x(extents[1] - extents[0]);
                    }
                )
                .attr("height", 5)
                .attr("rx", 2)
                .attr("ry", 2)
                .style("stroke-width", "1")
                .style("stroke",
                    function(c) {
                        if (side == "right") {
                            return colors[colors.length - c.cIndex];
                        }

                        return "none";
                    }
                )
                .style("fill",
                    function(c) {
                        if (side == "left") {
                            return colors[c.cIndex - 1];
                        }

                        return "none"
                    }
                );

            // Transform x position
            svgBrush.selectAll(".rects").selectAll("rect")
                .attr("transform", 
                    function(c) { 
                        var offset = 10;

                        if (c.side == "right") {
                            offset = 25;
                        }

                        return "translate(" + x(d3.extent(c.time)[0]) + "," + offset + ")"; 
                    }
                )

            brushmove();
        }        
    });
}

/**
 * Utility Functions
 */
 function brushstart() {
    svgBrush.classed("selecting", true);
}

function brushmove() {
    var s = brush.extent();
    var rects = svgBrush.selectAll(".rects").selectAll("rect");

    rects.classed("selected", 
        function(c) { 
            var extents = d3.extent(c.time);
            var checkbox = $('#checkbox-' + c.side + c.cIndex);
            var selected = true;

            // +1 to take into account the very last team fight
            if (s[0] <= extents[0] && extents[1] <= s[1] + 1) {
                checkbox.prop("checked", true);
            }
            else {             
                checkbox.prop("checked", false);
                selected = false;
            }

            toggleEllipse(checkbox[0]);
            return selected;
        }
    );
}

function brushend() {
    svgBrush.classed("selecting", !d3.event.target.empty());
}

 function toggleTier(element) {
    var tier = (element.value).split("-")[0];
    var side = (element.value).split("-")[1];

    loadDropDown(side, tier);
}

function toggleEllipse(element) {
    var side = (element.value).split("-")[0];
    var index = (element.value).split("-")[1];
    var display = element.checked ? "inline" : "none";

    svg.selectAll("ellipse")
        .filter(function(d) { 
            if (side == d.side) {
                return d.cIndex == index;
            }

            return false;
        }
        )
        .attr("display", display);
}

var enlargeEllipseData = function() {
    var ellipseIndex = (this.id).split('-')[1];
    var text = d3.select("#text-" + ellipseIndex);
    var side = ellipseIndex.replace(/[0-9]/g, '');

    var numberPattern = /\d+/g;

    svg.selectAll("ellipse")
        .transition().duration(250)
        .style("fill",
            function(c) {
                // All other ellipses
                if (c.cIndex != ellipseIndex.match(numberPattern) || c.side != side) {
                    return "gray";
                }
                // Selected ellipse
                else {
                    return colors[c.cIndex - 1];
                }

            }
        )
        .style("stroke",
            function(c) {
                if (c.side == "left") {
                    return "none";
                }
                else {
                    // All other ellipses
                    if (c.cIndex != ellipseIndex.match(numberPattern) || c.side != side) {
                        return "gray";
                    }
                    // Selected ellipse
                    else {
                        return colors[colors.length - c.cIndex];
                    }
                }
            }
        )

    text.classed('hover', true);
}

var shrinkEllipseData = function() {
    var ellipse = d3.select(this);
    var ellipseIndex = (this.id).split('-')[1];
    var text = d3.select("#text-"+ellipseIndex);
    
    svg.selectAll("ellipse")
        .transition().duration(250)
        .style("fill", 
            function(c) { 
                return colors[c.cIndex - 1]; 
            }
        )
        .style("stroke",
            function(c) {
                if (c.side == "left") {
                    return "none";
                }

                return colors[colors.length - c.cIndex];
            }
        );

    text.classed('hover', false);  

}

function getKeySecondToMax(obj, value) { 
    for (o in obj) {
        if(obj.hasOwnProperty(o)) {
            if (obj[o] === value) {
                return o;
            }
        }
    }
}

function secondToMaxValue(obj) { 
    var max = -1;
    var secondMax = -1;
    for(o in obj) {
        if(obj[o] > max) {
            secondMax = max;
            max = obj[o];
        } else if (obj[o] > secondMax) {
            secondMax = obj[o];
        }
    }
    return secondMax;
}

function objKeyOfMaxValue(obj) { 
    var max = -1;
    var key = "";
    for(o in obj){
        if(obj[o] > max) {
            max = obj[o];
            key = o;
        }
    }
    return key;
}

function create2DArray(rows) {
  var arr = [];

  for (var i=0;i<rows;i++) {
     arr[i] = [];
  }

  return arr;
}

function eucl(x1, y1, x2, y2) {
    dx = Math.abs(x1-x2);
    dy = Math.abs(y1-y2);
    distance = Math.sqrt((dx*dx) + (dy*dy));
    return(distance);
}   

function makeArrayOf(value, length) {
  var arr = [];
  var i = length;
  while (i--) {
    arr[i] = value;
  }
  return arr;
}

function avgArray(arr) {
    var newArr = [];
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] > 0) {
            newArr[i] = arr[i] / 5;
        }
        else {
            newArr[i] = 0;
        }
    }

    return newArr;
}

function euclArray(arr1, arr2, arr3, arr4) {
    var euclArr = [];
    for (var i = 0; i < arr1.length; i++) {
        euclArr[i] = eucl(arr1[i], arr2[i], arr3[i], arr4[i]);
    }
    return euclArr;
}

function menuChanged() {
    var selectedValue = d3.event.target.value;
    var side = (this.name).split("-")[1];

    reset(side);
    
    if (!isNaN(selectedValue) && selectedValue > 0) {
        getMatch(selectedValue, side);
    }
}


function filterDD(arr) {
    var newArr = [];
    var length = 0;

    for (var i = 0; i < arr.length; i++) {
        if (i == 0) {
            if (arr[i+1] != arr[i]+1) {
                arr[i] = 0;
            }
            else {
                newArr.push(arr[i]);
            }
        }
        else if (i == arr.length-1) {
            if (arr[i-1] != arr[i]-1) {
                arr[i] = 0;
            } 
            else {
                newArr.push(arr[i]);
            }
        } 
        else {
            if (arr[i-1] != arr[i]-1 && arr[i+1] != arr[i]+1) {
                arr[i] = 0;
            }
            else { 
                newArr.push(arr[i]);
            }
        }
    }
    return newArr;
}


</script>
</body>
</html>