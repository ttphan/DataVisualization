<!DOCTYPE html>
<html>
<head>
    <title>Exercise-3</title>
    <meta charset="utf-8">
    <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
    <link href=bootstrap-3.1.1-dist/css/bootstrap.css rel=stylesheet media="screen">
</head>

<!-- We define the css style information for the path. You can also have this information in a .css file -->
<!-- colors can be given as classes red - blue, but also as consecutive hexadecimal (0-f) numbers in the form of RGB (either 3 or 6 digits) so
For example: #00ff00 (green) , #f00 (red), #ff0 (yellow) #fff (white) #ccf (blue less saturated) etc -->
<!-- cursor allows you to define the form of the cursor when you are on top of the object -->

<style>
    svg {
        font: 10px sans-serif;
    }

    .gridCircle {
        opacity:0.5;
    }
    /*.background path {
        fill: none;
        stroke: #ccc;
        stroke-opacity: .4;
        shape-rendering: crispEdges;
    }

    .foreground path {
        fill: none;
        stroke: steelblue;
        stroke-width:1;
        stroke-opacity: .7;
    }

    .brush .extent {
        fill-opacity: .4;
        shape-rendering: crispEdges;
    }

    .axis line,
    .axis path {
        fill: none;
        stroke: #393b79;
        shape-rendering: crispEdges;
    }

    .axis text {
        text-shadow: 0 2px 0 #fff;
        cursor: move;
    }

    .outer {
        fill:none;
        stroke: #000;
    }
*/



</style>

<!-- definition of the area in the window -->
<div class="row">
    <div class="col-md-4" id ="svgArea"></div>
</div>


<body>

<script src=D3/d3.js></script>
<script src=jquery-2.1.0.min/jquery-2.1.0.min.js></script>

<script>

var margin = {top: 10, right: 10, bottom: 10, left: 10},
        width = 768,
        height = 768;

var x = {},
        y = {},
        dragging = {};



var line = d3.svg.line(),
        axis = d3.svg.axis().orient("left"),
        background,
        foreground;

var dimensions;


// Defines your svg element and also as a "g" (graphic) element that you can translate for your visualization
var publidVar;

var svg = d3.select("body").append("svg")// where are you placing your graphic (body) (div)
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g");
        //.attr("transform", "translate(" + 0 + "," + 0 + ")"); //


//!!!!!!!!!IMAGE HERE!!!!!!!!!!
// We draw the outer rectangle based on the outer class
svg.append("svg:image")
        .attr("x", margin.left)
        .attr("y", margin.top)
        .attr("width", width)
        .attr("height", height)
        .attr("xlink:href","HighResMap.jpg")





/**
 * Dit deel berekent de gemiddelde afstand van beide teams en de onderlinge afstand tussen teams.
 */

function eucl(x1, y1, x2, y2) {
    dx = Math.abs(x1-x2);
    dy = Math.abs(y1-y2);
    distance = Math.sqrt((dx*dx) + (dy*dy));
    return(distance);
}   

function makeArrayOf(value, length) {
  var arr = [];
  var i = length;
  while (i--) {
    arr[i] = value;
  }
  return arr;
}

function avgArray(arr) {
    var newArr = makeArrayOf(0, matchTime);
    for(var i = 0; i < arr.length; i++) {
        if(arr[i] > 0) {
            newArr[i] = arr[i] / 5;
        }
    }

    return newArr;
}

//var interTeamDistArr = euclArray(avgPosListWinX, avgPosListWinY, avgPosListLoseX, avgPosListLoseY);

function euclArray(arr1, arr2, arr3, arr4) {
    var euclArr = makeArrayOf(0, matchTime);
    for(var i = 0; i < arr1.length; i++) {
        euclArr[i] = eucl(arr1[i], arr2[i], arr3[i], arr4[i]);
    }
    return euclArr;
}

var matchTime = 1552;

var winTeamPlayers = [];
var loseTeamPlayers = [];

var xPosWin = 0;
var yPosWin = 0;

var xPosLose = 0;
var yPosLose = 0;

var posListWinX = makeArrayOf(0, matchTime);
var posListWinY = makeArrayOf(0, matchTime);

var posListLoseX = makeArrayOf(0, matchTime);
var posListLoseY = makeArrayOf(0, matchTime);

d3.csv("scripts/deliverables/match-569649581-zones.csv", function(error, data) {
    data.forEach(function(d) {
        d.t = +d.t;
        d.x = +d.x;
        d.y = +d.y;
        d.match = +d.match;
        d.team = d.team;
        d.player = d.player;
        d.won = +d.won;
        d.tstd = +d.tstd;
        d.tsync = +d.tsync;
        d.tper = +d.tper;
        d.tier = d.tier;
        d.zone = d.zone;
        //createPlayerLists(d);
        if(smallDDArray.indexOf(d.tsync)!=-1 && d.won==1){
            posListWinX[d.tsync] += d.x;
            posListWinY[d.tsync] += d.y;
        }else if(smallDDArray.indexOf(d.tsync)!=-1 && d.won==0) {
            posListLoseX[d.tsync] += d.x;
            posListLoseY[d.tsync] += d.y;
        }



        if(d.tsync == 546) {
            //console.log(data[546].x);

            if(d.won == 1) {
                xPosWin += d.x;
                yPosWin += d.y;
            }else{
                xPosLose += d.x;
                yPosLose += d.y;
            }
        }
    });

    var avgPosListWinX = avgArray(posListWinX);
    var avgPosListWinY = avgArray(posListWinY);

    var avgPosListLoseX = avgArray(posListLoseX);
    var avgPosListLoseY = avgArray(posListLoseY);

    var interTeamDistArr = euclArray(avgPosListWinX, avgPosListWinY, avgPosListLoseX, avgPosListLoseY);

    console.log(interTeamDistArr);

    var xPosWinAvg = xPosWin / 5;
    var yPosWinAvg = yPosWin / 5;
    var xPosLoseAvg = xPosLose / 5;
    var yPosLoseAvg = yPosLose / 5;
    console.log("xWin: " + xPosWinAvg + ", yWin: " + yPosWinAvg);
    console.log("xLose: " + xPosLoseAvg + ", yLose: " + yPosLoseAvg);
    console.log("Eucl. dist: " + eucl(xPosWinAvg, yPosWinAvg, xPosLoseAvg, yPosLoseAvg));

    //Hier lijsten maken met average positions per team per tijdstip waarop de DD van beide teams laag is.
    /*function averagePosWin(tsync) {

    }

    function averagePosLose(tsync) {

    }*/

    /**
    * Hier functie om players op te halen, weet niet of dit nog nodig is, hoorde bij een eerste aanpak van gisteravond.
    */
    console.log("winning team:" + winTeamPlayers);
    console.log("losing team:" + loseTeamPlayers);

    function createPlayerLists(d) {
        if(d.won == 1 && (winTeamPlayers.indexOf(d.player) == -1)) { //
            winTeamPlayers.push(d.player);
        } else if(d.won == 0 && (loseTeamPlayers.indexOf(d.player) == -1)){ //
            loseTeamPlayers.push(d.player);
        }
    }
});

//------------------------------------------------------------//


/**
 * Dit deel berekent de momenten waarop de DDs kleiner zijn dan een bepaald getal.
*/
var winSmallDDArray = [];
var loseSmallDDArray = [];

var smallDDArray = [];

d3.csv("scripts/deliverables/match-569649581-distance.csv",function(error, data) {
    data.forEach(function(d) {
        d.match = +d.match;
        d.team  = d.team;
        d.tsync = +d.tsync;
        d.DD    = +d.DD;
        d.Tier  = d.Tier;
        d.WinLose = d.WinLose;
        findSmallDdPerTeam(d);
        
    });

    smallDDIntersect(winSmallDDArray, loseSmallDDArray);

    var color = d3.scale.category10();
    
    //Just a prototype, trying this for one specific match
    function findSmallDdPerTeam(d) {
        if(d.WinLose == "Win") {
            if(d.tsync > 100 && d.DD <= 40) {  //100?, 40?
                winSmallDDArray.push(d.tsync);
            }
        }
        if(d.WinLose == "Lose") {
            if(d.tsync > 100 && d.DD <= 40) {  //100?, 40?
                loseSmallDDArray.push(d.tsync);
            }
        }
    }

    function smallDDIntersect(arr1, arr2) {
        for(var i = 0; i < arr1.length; i++) {
            for(var j = 0; j < arr2.length; j++) {
                if(arr1[i] == arr2[j]) {
                    smallDDArray.push(arr1[i]);
                }
            }
        }
        console.log(smallDDArray);
    }
});


//Inkleuren van de kaart.
	// We read the data
d3.csv("data/Dota-Labels.csv",function(error, data) {
    data.forEach(function(d) {
		d.x	= +d.x;
		d.y	= +d.y;
        d.SectionLabel = d.SectionLabel;
		d.LabelValue = +d.LabelValue;
    });

    var color = d3.scale.category20();


    circle = svg.append("g")
        .selectAll("circle")
        .data(data)
        .enter()
        .append("circle")
        .attr("cx", function(d){return ((d.x * 6) + 3) + 15})
        .attr("cy", function(d){return (((124 - d.y) * 6) + 3) + 15})
        .attr("r", 3)
        .attr("class","gridCircle")
        .style("fill", 
                function(d) { 
                                if(d.LabelValue != 17 && d.LabelValue != 18){
                                    return color(d.LabelValue); 
                                }
                            }
        );


});




/*


		// we create an array with the labels of the dimensions of our data. We will not use the species
		dimensions = d3.keys(data[0]);
		//.filter(function(d){return d !="species" });

		// we create the scale distribution for ordinal data
		x= d3.scale.ordinal().rangePoints([0, width], 1)
			.domain(dimensions);

		// y contains the scaling factors for all the dimensions


        for (i = 0; i < dimensions.length-1; i++) {
            y[dimensions[i]]  = d3.scale.linear()
                       .domain(d3.extent(data, function(d){return d[dimensions[i]]})).nice()
                       .range([height,0]);
                 }

/*      The loop above is equivalent to

        y.sepalLength  = d3.scale.linear()
                       .domain(d3.extent(data, function(d){return d.sepalLength})).nice()
                       .range([height,0]);
        y.sepalWidth  = d3.scale.linear()
					   .domain(d3.extent(data, function(d){return d.sepalWidth})).nice()
    				   .range([height,0]);

    	y.petalLength = d3.scale.linear()
					   .domain(d3.extent(data, function(d){return d.petalLength})).nice()
    				   .range([height,0]);

	   	y.petalWidth  = d3.scale.linear()
					   .domain(d3.extent(data, function(d){return d.petalWidth})).nice()
    				   .range([height,0]);
*/
		
		y.species = d3.scale.ordinal()
					.domain(["setosa","versicolor","virginica"])
					.rangePoints([height,0], 1);
    
    // If our lines are not selected (background), change their color to something "less" important
    /*background = svg.append("g")
            .attr("class", "background")
            .selectAll("path")
            .data(data)
            .enter()
            .append("path")
            .attr("d", path); // http://www.w3schools.com/svg/svg_path.asp (svg's are complex when they want to be)
    



    // If lines are selected change their color accordingly to their species color

    // Define the color scale - see scales https://github.com/mbostock/d3/wiki/Ordinal-Scales 
    var color = d3.scale.category10();

    foreground = svg.append("g")
            .attr("class", "foreground")
            .selectAll("path")
            .data(data)
            .enter()
            .append("path")
            .attr("d", path)
            .style("stroke", function(d){
                return color(d.species);});
            


     // create a "g" element that you can translate according to the number of dimensions your data has
    var g = svg.selectAll(".dimension")
            .data(dimensions)
            .enter().append("g")
            .attr("class", "dimension")
            .attr("transform", function(d) { return "translate(" + x(d) + ")"; })

    // Add an axis and title.
    g.append("g")
            .attr("class", "axis")
            .each(function(d) {
                d3.select(this).call(axis.scale(y[d])); })
            .append("text")
            .attr("text-anchor", "middle")
            .attr("y", -8)
            .text(String);

    // Add and store a brush for each axis.
    // d3.select(this) decides which axis you are working on and assigns an individual brush that you can manipulate
    // go to the function BRUSH to see how the selection/deselection works
    g.append("g")
            .attr("class", "brush")
            .each(function(d) {
                d3.select(this).call(y[d].brush = d3.svg.brush()
                        .y(y[d])
                        .on("brush", brush));
            })
            .selectAll("rect")
            .attr("x", -8)
            .attr("width", 16)
            .style("fill","#cc0");

});


function position(d) {
    var v = dragging[d];
    return v == null ? x(d) : v;
}

// Returns the path for a given data point.
function path(d) {
    return line(dimensions.map(function(p) { return [position(p), y[p](d[p])]; }));
}

// Handles a brush event, toggling the display of foreground lines.
function brush() {

    // Actives return the axis you are applying a brush to!
    // extents return the upper and lower limit of your selection
    var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
            extents = actives.map(function(p) { return y[p].brush.extent(); });


    foreground.style("display", function(d) {
            return actives.every(function(p, i) {
                var point = (y[p].ticks)?d[p]:y[p](d[p]);
                return extents[i][0] <= point && point <= extents[i][1];
            }) ? null : "none";
        });
}
*/

</script>



</body>
</html>